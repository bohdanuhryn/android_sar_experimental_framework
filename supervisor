Стосовно дослідження зараз можна виділити 2 напрями:
1. Фактори і метрики старіння
2. Моделі старіння і омолодження

Детальніше по цих 2-х напрямах.

І. Фактори і метрики.

Я реалізував каркас фреймворку, який дозволяє:
1) виконувати стресове тестування на мобільному девайсі чи емуляторі;
2) збирати логи з різних доступних джерел;
3) виконувати парсинг логів і на основі отриманих даних будувати результуючі таблиці ("розріджені" таблиці - містять логи з різних джерел, а id (часова мітка) для кожного запису індивідуальні; таблиці часових рядів, які містять відносно "чисті" дані, готові для статистичної обробки і наступних досліджень даних тими ж методами data mining).

Зараз займатимусь калібровкою фреймворку, щоб вже отримувати більш реальні дані і виконувати реальні тести. Намагаюсь передбачити в фреймворку засоби для розширення (додавати нові логи, які можна буде парсити, розширювати і модифікувати таблиці, які будуть опрацьовуватись і т.д.).

З конкретних практичних речей зараз готово і в розробці збір логів, парсинг і таблиця з часовим рядом для таких метрик як:
- Activity Launch Time (https://developer.android.com/topic/performance/vitals/launch-time). Цей параметр застосовувався для визначення наявності старіння в попередніх дослідженнях, але в дослідженні (https://www.researchgate.net/publication/311531652_Software_Aging_Analysis_of_the_Android_Mobile_OS, PDF прикріпив до листа) було зроблено акцент, що цей параметр не достатній і має певні обмеження в практичному застосуванні. Тому вони в роботі 2019 року додатково до цього параметра враховують метрики використання оперативної пам'яті і збирача сміття, щоб оцінювати групи метрик по ступеню достовірності того є старіння чи нема.
- Proportional Set Size (PSS)/Free & Cached Memory (FM/CM) - також попередньо застосовувались в роботах і в роботі 2019 року Activity Launch Time і PSS визначили як індикатори з "високим рівнем довіри".
- (new) Framestats FS - власне новий індикатор, який не був попередньо замічений мною в роботах, але який вартувало б перевірити, оскільки він може дати коректніші результати. Activity Launch Time - це час запуску екрана додатку, але значна частина додатків андроїд є "одноекранними" в цьому сенсі, оскільки після запуску відкривається одне вікно, а в ньому вже будується і малюється інтерфейс чи то засобами андроїд фреймворку, чи то іншими засобами кросплатформових фремворків чи гібридних додатків. В випадку Activity Launch Time в роботах перевіряють наступним чином - спеціально форсять перезапуск додатків в певних інтервалах (5 сек, 60 сек), щоб зібрати дані. В випадку Framestats такого мало б вже не бути і можна було б спостерігати за динамікою старіння вже в конкретному додатку без перезавантажень.
https://developer.android.com/training/testing/performance
https://developer.android.com/topic/performance/vitals/frozen
https://developer.android.com/topic/performance/vitals/render
Також виписав наступні метрики, що не були попередньо використані в дослідженнях, але я ще не почав їх застосовувати також:
- (new) Application Not Response (ANR):
https://developer.android.com/topic/performance/vitals/anr
- (new) Exceptions (EX):
https://developer.android.com/topic/performance/vitals/crash
- (new) Battery Power (BP). Нижче буду ще згадувати споживання батареї. Є ідея - інтенсивність споживання заряду як індикатор старіння. Можна проаналізувати зростання цієї інтенсивності і шукати кореляцію із активними процесами, які виконуються і те як вони завантажують систему.
https://developer.android.com/topic/performance/vitals/wakeup
https://developer.android.com/topic/performance/vitals/wakelock
https://developer.android.com/topic/performance/power/setup-battery-historian
https://developer.android.com/topic/performance/power/battery-historian#asd

Щодо проведення самих тестів і експериментів:
- планую зібрати декілька груп додатків, умовно поділивши їх на нативні і кросплатформові, і проганяти тестами з різними вхідними параметрами робочого навантаження, записуючи індикатори пам'яті, фреймів (час відображення одного фрейму), launch time;
- на зібраних даних можна показати наявний тренд з допомогою методі лінійної регресії, наприклад, щоб сказати співпадають прогнози фреймів і launch time, чи ні;
- показати наявність чи відсутність кореляції між використанням оперативної пам'яті і фреймами, launch Time;
- також дані про використання пам'яті містять дані про "тип" процесу, наприклад: native/sys (системні додатки), visible/foreground (активні додатки, які відображаються), cached (кешовані додатки, згорнуті користувачем, наприклад). Ці дані можна було б випробувати в контексті того, що ми говорили про фонові процеси.

ІІ. Моделі старіння і омолодження.

Ось стаття в якій використовували мережу перті і ланцюги маркова для побудови моделі старіння і омолодження із урахуванням поведінки користувача (також прикріплюю пдф): https://www.researchgate.net/publication/327289120_A_New_Software_Rejuvenation_Model_for_Android

Отже, в цій роботі об'єднали 3 мережі Маркова:
- поведінки користувача (телефон в режимі сну (Sleep) і в режимі використання користувачем (Active));
- старіння з та без активного омолодження (3 і 4 стани відповідно: система young - система old - стан відновлення recovering - стан rebirth (активне омолодження))

Нова побудована модель враховує те, що активне омолодження на випередження (ще до переходу в стан old) краще застосовувати в час, коли система перебуває в стані Sleep. Розробка оптимальної стратегії омолодження, що дозволяє покращити user experience і мінімізувати втручання користувача.

Активне омолодження - перезавантаження пристрою/компонент системи/додатків до того, як система перейде в стан старіння чи відбудеться збій.

В результаті вони підрахували, що найкраще виконувати омолодження через 30 годин. Але всі дані були взяті з припущенням (assumed). Відповідно самі ж пропонують в подальших дослідженнях врахувати фактори як АЗ так і ПЗ, застосовувати методи машинного навчання.

Поки що я туманно уявляю, як можна застосувати для цієї моделі немарківські моделі, які б враховували "еволюцію" попередніх станів. Хоча можливо таке можна зробити, якщо додати додаткові стани або ви б могли порадити що з їх схемою станів можна зробити.

Мої (і не тільки мої) варіанти як розширити і продовжити цю роботу:
- додати додаткові стани пристрою. Автори самі зазначали, що не враховують фактор стану заряду батареї. Телефони енергозалежні, тому можна виділити додаткові стани "заряджається", "низький заряд", "критично низький заряд". Адже інколи телефон може протриматись на декількох % заряду досить довго, але якщо запускати в цей момент додаткові процеси, то негативно вплине на UX і скоротить тривалість роботи.
- застосувати їх модель на реальних (тестових) даних. Уявляю собі так: генеруємо стресове тестування з урахуванням поведінки користувача; збираємо реальні дані; вставляємо в їх модель і оцінюємо результати.
- порівняти їх модель із моделями на основі машинного навчання (https://www.researchgate.net/publication/325703746_Using_machine_learning_for_software_aging_detection_in_Android_system). Схема починається подібно як я писав в попередньому пункті, але додається реалізація алгоритмів машинного навчання і порівнюємо отримані результати.
- розробка гібридного підходу комбінуючи машинне навчання і модель. вказали на це самі автори.
